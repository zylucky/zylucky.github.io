[{"title":"Hello World","url":"/4a17b156.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"JavaScript几种继承方式及优缺点整理","url":"/29cde879.html","content":"ES5继承\n每创建一个构造函数，则该函数都会自动带有一个 prototype 属性。该属性是一个指针，指向一个对象，该对象称之为原型对象。\n原型对象上默认有一个属性 constructor ，该属性也是一个指针，指向其关联的构造函数。\n通过构造函数产生的实例对象，都拥有一个内部指向，指向了原型对象。其实例能够访问原型对象上的所有属性和方法。\n\n构造函数、原型和实例的关系：每一个构造函数都有一个原型对象 prototype ，每一个原型对象都有一个指向构造函数的指针 constructor ，而每一个实例都包含一个指向原型对象的内部指针。\n原型继承function Parent() &#123;    this.name = &#x27;parent&#x27;;    this.parentObj = &#123;        info: &#x27;parent中的对象&#x27;    &#125;;    this.action = function() &#123;        return this.name;    &#125;&#125;// 往原型链添加一个方法Parent.prototype.getName = function() &#123;    return this.name;&#125;function Child() &#123;    this.name = &#x27;child&#x27;;&#125;// 实例化Parent，链接到Child的原型链上Child.prototype = new Parent();const child = new Child();console.log(child.name); // child&quot;// 缺点const child1 = new Child();child.parentObj.info = &#x27;child中的对象&#x27;;// child 和 child1实例共享引用属性console.log(child1.parentObj.info); // child中的对象\n\n关键点：子类原型等于父类的实例 Child.prototype = new Person()\n特点：\n\n实例可继承的属性有：实例的构造函数的属性，父类构造函数的属性，父类原型上的属性。（新实例不会继承父类实例的属性）\n\n注意事项：\n\n新实例无法向父类构造函数传参\n继承单一\n所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改）\n\n构造函数继承（call或apply）function Parent() &#123;  this.name = &#x27;parent&#x27;;  this.action = function () &#123;    return this.name;  &#125;,  this.arr = [1,2];&#125;Parent.prototype.getName = function () &#123;  return this.name;&#125;function Child () &#123;  // 注意：若子类的属性名和父类的一样，则看它的顺序，谁在下面用谁的声明  this.name = &#x27;Child&#x27;;  // Parent.call(this);  Parent.apply(this);&#125;const child1 = new Child();const child2 = new Child();child2.arr.push(3);child.getName(); // 报错，继承不了父类原型上的东西console.log(&#x27;child1 ---&gt;&#x27;, child1);console.log(&#x27;child2 ---&gt;&#x27;, child2);\n\n关键点：用 call 或 apply 将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））Parent.call(this, &#39;reng&#39;)\n特点：\n\n只继承了父类构造函数的属性，没有继承父类原型的属性\n解决了原型链继承的注意事项（缺点）1，2，3\n可以继承多个构造函数的属性（call可以多个）\n在子实例中可以向父实例传参\n\n注意事项：\n\n只能继承父类构造函数的属性\n无法实现构造函数的复用。（每次用每次都要重新调用）\n每个新实例都有构造函数的副本，臃肿\n\n组合继承（call + prototype）function Parent() &#123;  this.name = &#x27;parent&#x27;;  this.action = function () &#123;    return this.name;  &#125;,  this.arr = [1,2];&#125;Parent.prototype.getName = function () &#123;  return this.name;&#125;function Child() &#123;  this.name = &#x27;child&#x27;;  Parent.call(this);&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;const child1 = new Child();console.log(child1)\n\n关键点：结合了两种模式的优点–向父类传参（call）和复用（prototype）\n特点：\n\n可以继承父类原型上的属性，可以传参，可复用\n每个新实例引入的构造函数属性是私有的\n\n注意事项：\n\n调用了两次父类的构造函数（耗内存）\n子类的构造函数会代替原型上的那个父类构造函数（call相当于拿到了父类构造函数的副本）\n\n原型式继承function Person(name) &#123;  this.name = name;&#125;Person.prototype.job = &#x27;IT&#x27;;Person.prototype.sayHello = function () &#123;  console.log(&#x27;Hello &#x27; + this.name);&#125;var person = new Person(&#x27;zylucky&#x27;);person.sayHello(); // Hello zyluckyfunction objFn(o) &#123;    o.objFnPrototype = &quot;我是 objFnPrototype&quot;;    function F() &#123;&#125;;    F.prototype = o;    return new F();&#125;const op = new Person();const oa = objFn(op);console.log(oa instanceof Person); // trueconsole.log(oa.job); // ITconst a = objFn(&#123;    name: &quot;name1&quot;&#125;);console.log(a.name); //name1console.log(a.objFnPrototype); //我是 objFnPrototype\n\n关键点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了可以随意增添属性的实例或对象。Object.create()就是这个原理。\n特点：\n\n类似于复制一个对象，用函数来包装\n\n注意事项：\n\n所有的实例都会继承原型上的属性\n无法实现复用。（新实例属性都是后面添加的）\n\nObject.create()方法规范了原型式继承。这个方法接收两个参数，一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。\n// 传一个参数的时候var anotherPerson = Object.create(new Person());console.log(anotherPerson.job); // ITconsole.log(anotherPerson instanceof Person); // true// 传两个参数的时候var anotherPerson = Object.create(new Person(), &#123;    name: &#123;      value: &#x27;zylucky&#x27;    &#125;&#125;);anotherPerson.sayHello(); // Hello zylucky\n\n寄生式继承function Person(name) &#123;  this.name = name;&#125;...function object(obj) &#123;    function F()&#123;&#125;    F.prototype = obj;    return new F();&#125;var sup = new Person();// 以上是原型式继承，给原型式继承再套个壳子传递参数function subobject(obj) &#123;    var sub = object(obj);    sub.name = &#x27;zylucky&#x27;;    return sub;&#125;var sup2 = subobject(sup);// 这个函数经过声明后就成了可增添属性的对象console.log(sup2.name); // &#x27;zylucky&#x27;console.log(sup2 instanceof Person); // true\n\n关键点：就是给原型式继承外面套个壳子。\n特点：\n\n没有创建自定义类型，因为只是套了个壳子，返回对象，这个函数顺理成章就成了创建的新对象。\n\n注意事项：\n\n没用到原型，无法复用\n\n寄生组合式继承它跟组合继承一样，都比较常用。\n寄生：在函数内返回对象然后调用\n组合：\n\n函数的原型等于另一个实例\n在函数中用apply或call引入另一个构造函数，可传参\n\nfunction Person(name) &#123;  this.name = name;&#125;...// 寄生function object(obj) &#123;    function F()&#123;&#125;    F.prototype = obj;    return new F();&#125;// object是F实例的另一种表示方法var obj = object(Person.prototype);// obj实例（F实例）的原型继承了父类函数的原型// 上述更像是原型链继承，只不过只继承了原型属性// 组合function Sub() &#123;    this.age = 100;    Person.call(this); // 这个继承了父类构造函数的属性&#125; // 解决了组合式两次调用构造函数属性的特点// 重点Sub.prototype = obj;console.log(Sub.prototype.constructor); // Personobj.constructor = Sub; // 一定要修复实例console.log(Sub.prototype.constructor); // Subvar sub1 = new Sub();// Sub实例就继承了构造函数属性，父类实例，object的函数属性console.log(sub1.job); // frontendconsole.log(sub1 instanceof Person); // true\n\n重点：修复了组合继承的问题\n在上面的问题中，你可能发现了这么一个注释obj.constructor = Sub; // 一定要修复实例。为什么要修正子类的构造函数的指向呢？\n因为在不修正这个指向的时候，在获取构造函数返回的时候，在调用同名属性或方法取值上可能造成混乱。比如下面：\nfunction Car() &#123; &#125;Car.prototype.orderOneLikeThis = function() &#123;  // Clone producing function    return new this.constructor();&#125;Car.prototype.advertise = function () &#123;    console.log(&quot;I am a generic car.&quot;);&#125;function BMW() &#123; &#125;BMW.prototype = Object.create(Car.prototype);BMW.prototype.constructor = BMW;              // Resetting the constructor propertyBMW.prototype.advertise = function () &#123;    console.log(&quot;I am BMW with lots of uber features.&quot;);&#125;var x5 = new BMW();var myNewToy = x5.orderOneLikeThis();myNewToy.advertise(); // =&gt; &quot;I am BMW ...&quot; if `BMW.prototype.constructor = BMW;` is not                       // commented; &quot;I am a generic car.&quot; otherwise.\n\nES6继承在 ES6 中，直接使用 extends 关键字来实现 JavaScript 继承，Class之间通过使用extends关键字，这比通过修改原型链实现继承，要方便清晰很多。并且 babel 编辑之后，它采用的也是 寄生组合继承的方式，这种方式是较优的解决继承的方式。\nclass Parent2 &#123;  constructor(name) &#123;    this.name = name;  &#125;  getName = function ()&#123;    return this.name;  &#125;&#125;class Child2 extends Parent2 &#123;  constructor(name, age) &#123;    super(name);    this.age = age;  &#125;&#125;const child3 = new Child2(&#x27;parent&#x27;, 22);const child4 = new Child2(&#x27;parent1&#x27;, 25);console.log(child3.getName());console.log(child3);console.log(child4);\n\n子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象。因此，只有调用super之后，才可以使用this关键字。\nprototype  和 __proto__ \n一个继承语句同时存在两条继承链：一条实现属性继承，一条实现方法的继承。\nclass A extends B&#123;&#125;A.__proto__ === B;  //继承属性A.prototype.__proto__ == B.prototype;//继承方法\n\n总结总结ES5\nES5的继承可以用下图概括：\n\n总结ES6\nES6的继承可以用下图概括：\n\n"},{"title":"Vue nextTick实现原理","url":"/32f3b6bf.html","content":"nextTick 涉及的点，主要包含下面这些1、任务队列callbacks2、任务队列执行函数 flushCallbacks3、控制（宏任务，微任务）注册标志位 pending4、宏任务，微任务\n\nVue异步更新vue实现dom更新是异步完成的，我们可以从下面这个例子中就能看的出\n&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;button type=&quot;button&quot; @click=&quot;handleClk&quot;&gt;点击&lt;/button&gt;\t\t&lt;h3 ref=&quot;msgRef&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt;\t&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt;    new Vue(&#123;    el: &#x27;#app&#x27;,    data() &#123;        return&#123;            msg: &#x27;nextTick原理&#x27;        &#125;    &#125;,    methods:&#123;        handleClk()&#123;            this.msg = &#x27;理解nextTick原理&#x27;;            console.log(this.$refs.msgRef.innerText);//nextTick原理            this.$nextTick(()=&gt;&#123;                console.log(this.$refs.msgRef.innerText);//理解nextTick原理            &#125;)        &#125;    &#125;&#125;);&lt;/script&gt;\n\n从上代码可以看出，我们改变了msg后，立马去输出h3标签的text值，发现还是原来的值。这就很明显了，vue的dom更新，并不是同步的，而是异步的，所以在输出时，实际dom还并没有更新。\n原因：如果是同步的，当我们频繁的去改变状态值时，会频繁的导致我们的dom更新。\n为什么用Vue.nextTick()首先来了解一下JS的运行机制。\nJS运行机制（Event Loop）JS执行是单线程的，它是基于事件循环的。\n\n所有同步任务都在主线程上执行，形成一个执行栈。\n\n主线程之外，会存在一个任务队列，只要异步任务有了结果，就在任务队列中放置一个事件。\n\n当执行栈中的所有同步任务执行完后，就会读取任务队列。那些对应的异步任务，会结束等待状态，进入执行栈。\n\n主线程不断重复第三步。\n\n\n这里主线程的执行过程就是一个tick，而所有的异步结果都是通过任务队列来调度。Event Loop 分为宏任务和微任务，无论是执行宏任务还是微任务，完成后都会进入到一下tick，并在两个**tick**之间进行UI渲染。\n由于Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了 Vue.nextTick()方法。\n什么是Vue.nextTick()是Vue的核心方法之一，官方文档解释如下：\n在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。\n由于宏任务耗费的时间是大于微任务的，所以在浏览器支持的情况下，优先使用微任务。如果浏览器不支持微任务，再使用宏任务。\n// 空函数，可用作函数占位符import &#123; noop &#125; from &#x27;shared/util&#x27; // 错误处理函数import &#123; handleError &#125; from &#x27;./error&#x27;// 是否是IE、IOS、内置函数import &#123; isIE, isIOS, isNative &#125; from &#x27;./env&#x27;// 使用 MicroTask 的标识符，这里是因为火狐在&lt;=53时 无法触发微任务，在modules/events.js文件中引用进行安全排除export let isUsingMicroTask = false // 用来存储所有需要执行的回调函数const callbacks = []// 用来标志是否正在执行回调函数let pending = false // 对callbacks进行遍历，然后执行相应的回调函数function flushCallbacks () &#123;    //将pending再次置为false，表示下一个flushCallbacks函数可以进入浏览器的异步任务队列了    pending = false    // 这里拷贝的原因是：    // 有的cb 执行过程中又会往callbacks中加入内容    // 比如 $nextTick的回调函数里还有$nextTick    // 后者的应该放到下一轮的nextTick 中执行    // 所以拷贝一份当前的，遍历执行完当前的即可，避免无休止的执行下去    const copies = callbcks.slice(0)    callbacks.length = 0    for(let i = 0; i &lt; copies.length; i++) &#123;        copies[i]()    &#125;&#125;let timerFunc // 异步执行函数 用于异步延迟调用 flushCallbacks 函数// 在事件处理程序中使用(宏)任务会导致一些奇怪的行为// 因此，我们现在再次在任何地方使用微任务。// 优先使用 Promiseif(typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123;    const p = Promise.resolve()    timerFunc = () =&gt; &#123;        p.then(flushCallbacks)        // IOS 的UIWebView, Promise.then 回调被推入 microTask 队列，但是队列可能不会如期执行        // 因此，添加一个空计时器强制执行 microTask        if(isIOS) setTimeout(noop)    &#125;    isUsingMicroTask = true&#125; else if(!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; (isNative(MutationObserver) || MutationObserver.toString === &#x27;[object MutationObserverConstructor]&#x27;)) &#123;    // 当 原生Promise 不可用时，使用 原生MutationObserver    // e.g. PhantomJS, iOS7, Android 4.4    let counter = 1    // 创建MO实例，监听到DOM变动后会执行回调flushCallbacks    const observer = new MutationObserver(flushCallbacks)    const textNode = document.createTextNode(String(counter))    observer.observe(textNode, &#123;        characterData: true // 设置true 表示观察目标的改变    &#125;)    // 每次执行timerFunc 都会让文本节点的内容在 0/1之间切换    // 切换之后将新值复制到 MO 观测的文本节点上    // 节点内容变化会触发回调    timerFunc = () =&gt; &#123;        counter = (counter + 1) % 2        textNode.data = String(counter) // 触发回调    &#125;    isUsingMicroTask = true&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123;    timerFunc = () =&gt; &#123;        setImmediate(flushCallbacks)    &#125;&#125; else &#123;    timerFunc = () =&gt; &#123;        setTimeout(flushCallbacks, 0)    &#125;&#125;\n\n延迟调用优先级如下：\nPromise &gt; MutationObserver &gt; setImmediate &gt; setTimeout，前两个属于微任务，后两个属于宏任务。\n\nPromise：Promise对象用于表示一个异步操作的最终完成 (或失败)及其结果值。\n\nMutationObserver ：MutationObserver接口提供了监视对DOM树所做更改的能力。\n\nsetImmediate：setImmediate方法用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数。\n\nsetTimeout：setTimeout方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码。\n\n\nexport function nextTick(cb? Function, ctx: Object) &#123;    let _resolve    //将nextTick的回调函数用 try catch包装了一层，方便异常捕获    //然后将包装后的回调函数会统一处理push进callbacks数组    callbacks.push(() =&gt; &#123;        if(cb) &#123;            try &#123;                cb.call(ctx)            &#125; catch(e) &#123;                handleError(e, ctx, &#x27;nextTick&#x27;)            &#125;        &#125; else if (_resolve) &#123;            _resolve(ctx)        &#125;    &#125;)    // pending 为false 说明本轮事件循环中没有执行过timerFunc()    if(!pending) &#123;        pending = true        timerFunc()    &#125;    // 当不传入 cb 参数时，提供一个promise化的调用     // 如nextTick().then(() =&gt; &#123;&#125;)    // 当_resolve执行时，就会跳转到then逻辑中    if(!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123;        return new Promise(resolve =&gt; &#123;            _resolve = resolve        &#125;)    &#125;&#125;\n\nnext-tick.js 对外暴露了nextTick这一个参数，所以每次调用Vue.nextTick时会执行：\n\n把传入的回调函数cb压入callbacks数组\n\n执行timerFunc函数，延迟调用 flushCallbacks 函数\n\n遍历执行 callbacks 数组中的所有函数\n\n\n这里的 callbacks 没有直接在 nextTick 中执行回调函数的原因是保证在同一个 tick 内多次执行nextTick，不会开启多个异步任务，而是把这些异步任务都压成一个同步任务，在下一个 tick 执行完毕。\n总结原理\n将传递的回调函数用try catch包裹后然后放进callback数组。\n\n执行timerFunc函数，在浏览器的异步任务队列放入一个刷新callbacks数组的函数。\n\n因为兼容问题，vue做了微任务向宏任务的降级方案\n\n\n使用\n在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。原因：是created()钩子函数执行时DOM其实并未进行渲染。\n在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作应该放在Vue.nextTick()的回调函数中。原因：Vue异步执行DOM更新，只要观察到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变，如果同一个watcher被多次触发，只会被推入到队列中一次。\n\n"},{"title":"iview的Upload图片上传","url":"/d9a8bb34.html","content":"iview的upload上传组件，项目中经常会遇到上传图片的需求，还需要控制图片进行预览、大小限制、手动控制上传等操作，下面代码是直接通过iview中的upload组件来进行处理图片的自动、手动上传，以及本地图片预览方式。                                               \n&lt;template&gt;\t&lt;Upload     ref=&quot;upload&quot;     name=&quot;qmfile&quot;     :show-upload-list=&quot;false&quot;     :on-success=&quot;handleSuccess&quot;     :format=&quot;[&#x27;jpg&#x27;,&#x27;jpeg&#x27;,&#x27;png&#x27;]&quot;     :max-size=&quot;2048&quot;     :on-format-error=&quot;handleFormatError&quot;     :on-exceeded-size=&quot;handleMaxSize&quot;     :before-upload=&quot;handleBeforeUpload&quot;     type=&quot;drag&quot;     action=&quot;/activity/uploadIcon&quot;\t&gt;      &lt;div style=&quot;display: flex;align-items: center;justify-content: center;height: 100%;&quot; v-if=&quot;!formParams.currentImgUrl&quot;&gt;        &lt;Icon type=&quot;md-add&quot; size=&quot;40&quot; color=&quot;#ffffff&quot;&gt;&lt;/Icon&gt;      &lt;/div&gt;      &lt;img  v-if=&quot;formParams.currentImgUrl&quot; : src=&quot;formParams.currentImgUrl&quot;  alt=&quot;&quot; class=&quot;show-img&quot; &gt;    &lt;/Upload&gt;&lt;/template&gt;&lt;script&gt;\texport default&#123;  \tdata()&#123;    \treturn&#123;      \tformParams: &#123;          currentImgUrl: &#x27;&#x27;,//当前展示图片（也可以直接使用uploadList）          file: &#123;&#125;,//文件流          uploadList: [],//图片列表        &#125;,      &#125;    &#125;,  \tmethods: &#123;    \thandleSuccess (res, file) &#123;        \t\t//上传成功返回处理            if(res.code == 10000)&#123;                this.formParams.currentImgUrl = res.img_path;                this.formParams.uploadList[0] = res.img_path;            &#125;else&#123;                this.$Message.destroy();                this.$Message.error(res.msg);            &#125;        &#125;,        handleFormatError (file) &#123;            this.$Message.destroy();            this.$Message.warning(&#123;                content: file.name + &#x27;的文件格式不正确，请选择jpg或png&#x27;            &#125;);        &#125;,        handleMaxSize (file) &#123;            this.$Message.destroy();            this.$Message.warning(&#123;                content: &#x27;文件  &#x27; + file.name + &#x27; 太大, 超出 2M.&#x27;            &#125;);        &#125;,        handleBeforeUpload (file) &#123;        \t//本地预览的两种方式          //1 转换成本地可预览路径 2 转换成Base64进行本地预览          // this.formParams.currentImgUrl = URL.createObjectURL(file);//本地可预览路径          this.formParams.file = &#123;&#125;;//清空上次          this.formParams.uploadList = [];//清空上次          this.formParams.file = file;          // 转换Base64          const reader = new FileReader();          reader.readAsDataURL(file);          reader.onload = () =&gt; &#123;            const _base64 = reader.result;            this.formParams.currentImgUrl = _base64;            this.formParams.uploadList[0] = _base64;          &#125;          //限制图片上传数量          const check = this.formParams.uploadList.length &lt; 1;          if (!check) &#123;            this.$Message.destroy();            this.$Message.warning(&#123;              content: &#x27;最多上传一张图片&#x27;            &#125;);          &#125;          return check;//false将不执行上传          //注意：手动上传可在此直接 return false，调用时直接使用：          //this.$refs.upload.post(this.formParams.file);        &#125;    &#125;      &#125;&lt;/script&gt;"},{"title":"node版本管理工具：nvm安装及使用","url":"/b7954342.html","content":"日常开发中，有些项目较老使用的还是老版本node，有些项目又必须使用较新版本的node，但是新版本node对于老版本不兼容，这时候就需要我们开发环境能灵活切换想要的node版本去处理项目。于是，就产生了node版本控制器（nvm）。              \n准备首先需要卸载本机已经安装的node（没有安装可忽略）\n下载下载nvm工具 链接地址: https://github.com/coreybutler/nvm-windows/releases ，下载后直接解压就可以安装了,安装的时候目录尽量安装好找到的地方。\n\n注意：安装时弹出的第一个是nvm的安装路径，第二个是node的安装路径\n\n\n安装完成后需要进行配置//配置淘宝镜像/**node下载源*/nvm node_mirror https://npm.taobao.org/mirrors/node//**npm下载源*/nvm npm_mirror https://npm.taobao.org/mirrors/npm/\n\nwindows下nvm的命令（[]中的参数非必填）nvm arch                         查看当前系统的位数和当前nodejs的位数nvm install &lt;version&gt; [arch]     安装制定版本的node 并且可以指定平台 version 版本号  arch 平台nvm list [available]           - nvm list   查看已经安装的版本  - nvm list installed 查看已经安装的版本  - nvm list available 查看网络可以安装的版本nvm on                           打开nodejs版本控制nvm off                          关闭nodejs版本控制nvm proxy [url]                  查看和设置代理nvm node_mirror [url]            设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/nvm npm_mirror [url]             设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是：https://github.com/npm/npm/archive/.nvm uninstall &lt;version&gt;          卸载制定的版本nvm use [version] [arch]         切换制定的node版本和位数nvm root [path]                  设置和查看root路径nvm version                      查看当前的版本\n\n安装和切换node的几个简单命令使用nvm v                        //查看nvm版本nvm install 14.2.0 64-bit    //安装node 14.2.0 64-bit的版本nvm use 14.2.0               //使用node14.0.0的版本node -v                      // 查看版本切换是否成功nvm list                     //查看以己经安装的// 注意：切换版本时以管理员的方式打开命令框\n\n"},{"title":"vue-cli4.0搭建vue项目","url":"/c87a1b81.html","content":"摘要随着vue-cli脚手架的升级，vue-cli2.0版本与vue-cli3.0+版本搭建出来的vue项目也有了一些变化，下面是整理的个人从脚手架升级到vue项目创建的一个过程。\n\n本项目还会融合axios请求封装，可运行实测；\n接口统一管理，以及调用方式使用；\n环境区分（开发、生产、预生产、测试）；升级vue脚手架\n全局卸载旧版本脚手架（已升级可忽略）npm uninstall vue-cli -g    或yarn remove vue-cli -g\nnode安装最近的版本（不必是最新），我本机安装版本v12.16.1\n安装最新的vue-clinpm install -g @vue/cli\n查看是否已经安装成功vue --version 或 vue -V //查看版本号\n\n注意：vue-cli2.0升级后（3.0+以上）如果你还需要遗产vue init功能，可以安装一个全局桥，这样你就可以继续运行你的vue-cli2.X版本的项目以及通过之前的vue init webpack &#39;项目名&#39;来创建项目了，命令行如下：\nnpm install -g @vue/cli-init\n创建项目\n开始创建vue create &#39;项目名称&#39;default是使用默认配置(在这里我们选择Vue 2版本)Manually select features 是自定义配置这里选择自定义配置，然后回车下一步\n\n选择配置（自定义配置），上下箭头选择空格键确认*好代表选中，回车键下一步（此处根据自己项目需要可进行选择安装，也可后续自己安装）是否使用history模式来创建路由，这里选择否，后期可更改css预处理这里选择的第一项您希望Babel, ESLint 配置的存放位置，我们选择在专用的配置文件中\n In dedicated config files //在专用的配置文件中In package.json //在package.json\n Save this as a preset for future projects?(y/N) （是否保存配置 我们可以选择Y ，保存后下次构建项目的时候就可以直用这次的配置构建项目）\n\n项目创建好后\n cd &#x27;项目目录&#x27; //进入项目根目录npm run serve //运行项目\n\n\n\n然后在浏览器输入http://localhost:8080,就可以看到运行界面了\n项目修改环境配置\n根目录创建环境配置文件以及vue.config.js配置文件\n vue-cli-service build --mode production    //--mode后面跟的是创建的配置文件的名字\n\n.env.development文件\n # just a flag 开发环境（默认）ENV = &#x27;development&#x27;# base apiVUE_APP_BASE_API = &#x27;/dev-api&#x27;\n .env.production文件\n # just a flag 线上环境（打包）ENV = &#x27;production&#x27;# base apiVUE_APP_BASE_API = &#x27;/prod-api&#x27;\nvue.config.js文件,改配置文件中的代理配置是为后面本地测试接口时使用，不然会跨域 配置详情可参考vue-cli\n // Vue.config.jsmodule.exports = &#123;    publicPath: &#x27;/&#x27;, //基本路径    outputDir: &#x27;dist&#x27;, //构建时的输出目录    assetsDir: &#x27;static&#x27;, //放置静态资源的目录    indexPath: &#x27;index.html&#x27;, //html的输出路径    productionSourceMap: false, // 生产环境是否生成 sourceMap 文件    devServer: &#123;        open: true,        proxy: &#123;            &#x27;/dev-api&#x27;: &#123;                target: &#x27;http://api.yckindergarten.com.cn&#x27;,//设置你调用的接口域名和端口号 别忘了加http                changeOrigin: true,                pathRewrite:&#123;                    &#x27;^/dev-api&#x27;:&#x27;&#x27;//这里理解成用‘/api’代替target里面的地址，后面组件中我们掉接口时直接用api代替                               //比如我要调用&#x27;http://40.00.100.133:3002/user/login&#x27;，直接写‘/api/user/login’即可                &#125;            &#125;            // &#x27;/foo&#x27;: &#123;            //     target: &#x27;&lt;other_url&gt;&#x27;            // &#125;            //...        &#125;    &#125;&#125;\naxios封装配置\n安装axios、element-ui输入命令 npm install --save element-ui引入项目打开 main.js 文件\n import Vue from &#x27;vue&#x27;import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;Vue.config.productionTip = falseVue.use(ElementUI)console.log(process.env.VUE_APP_BASE_API)//测试可查看输出当前环境new Vue(&#123;  router,//路由  store,//状态管理  render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)\n安装 axios、qs 命令行输入命令 npm install --save axios qs\n\n在src文件夹下新建http目录，并在http目录下创建三个文件\n  config.js独立的数据请求配置文件\n // 接口配置文件export default &#123;    //请求方式    method: &#x27;post&#x27;,    // 基础url前缀    baseURL: process.env.VUE_APP_BASE_API,//取环境文件中定义的地址    // 请求头信息    headers: &#123;        &#x27;Content-Type&#x27;: &#x27;application/json;charset=UTF-8&#x27;,        &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,        &#x27;Appid&#x27;: &#x27;123456&#x27;,        &#x27;Token&#x27;: &#x27;&#x27;    &#125;,    // 参数    data: &#123;&#125;,    // 设置超时时间    timeout: 10000,    // 携带凭证    withCredentials: false,    // 返回数据类型    responseType: &#x27;json&#x27;&#125;\n  instance.js请求axios封装、拦截、处理文件\n  // axios 封装、拦截、统一请求处理import axios from &#x27;axios&#x27; //安装后引入import config from &#x27;./config.js&#x27; //引入配置文件import qs from &#x27;qs&#x27; //序列化数据请求export default function $axios(options) &#123;    return new Promise((resolve, reject) =&gt; &#123;        const instance = axios.create(&#123;            baseURL: config.baseURL,            headers: &#123;&#125;,            transformResponse: [function (data) &#123; &#125;]        &#125;)        // request 拦截器        instance.interceptors.request.use(            config =&gt; &#123;                // Tip: 1                // 请求开始的时候可以结合 vuex 开启全屏的 loading 动画                // Tip: 2                 // 带上 token , 可以结合 vuex 或者重 localStorage                // if (store.getters.token) &#123;                //     config.headers[&#x27;X-Token&#x27;] = getToken() // 让每个请求携带token--[&#x27;X-Token&#x27;]为自定义key 请根据实际情况自行修改                // &#125; else &#123;                //     // 重定向到登录页面                    // &#125;                // Tip: 3                // 根据请求方法，序列化传来的参数，根据后端需求是否序列化                if (config.method.toLocaleLowerCase() === &#x27;post&#x27;                    || config.method.toLocaleLowerCase() === &#x27;put&#x27;                    || config.method.toLocaleLowerCase() === &#x27;delete&#x27;) &#123;                    config.data = qs.stringify(config.data)                &#125;                // console.log(config.data);                return config            &#125;,            error =&gt; &#123;                // 请求错误时做些事(接口错误、超时等)                // Tip: 4                // 关闭loadding                console.log(&#x27;request:&#x27;, error)                //  1.判断请求超时                if (error.code === &#x27;ECONNABORTED&#x27; &amp;&amp; error.message.indexOf(&#x27;timeout&#x27;) !== -1) &#123;                    console.log(&#x27;根据你设置的timeout/真的请求超时 判断请求现在超时了，你可以在这里加入超时的处理方案&#x27;)                    // return service.request(originalRequest);//例如再重复请求一次                &#125;                //  2.需要重定向到错误页面                const errorInfo = error.response                console.log(errorInfo)                if (errorInfo) &#123;                    // error =errorInfo.data//页面那边catch的时候就能拿到详细的错误信息,看最下边的Promise.reject                    const errorStatus = errorInfo.status; // 404 403 500 ... 等                    // router.push(&#123;                    //     path: `/error/$&#123;errorStatus&#125;`                    // &#125;)                &#125;                return Promise.reject(error) // 在调用的那边可以拿到(catch)你想返回的错误信息            &#125;        )        // response 拦截器        instance.interceptors.response.use(            response =&gt; &#123;                let data;                // IE9时response.data是undefined，因此需要使用response.request.responseText(Stringify后的字符串)                if (response.data == undefined) &#123;                    data = response.request.responseText                &#125; else &#123;                    data = response.data                &#125;                // console.log(response);                // 根据返回的code值来做不同的处理（和后端约定）                switch (data.code) &#123;                    case &#x27;&#x27;:                        break;                    default:                &#125;                // 若不是正确的返回code，且已经登录，就抛出错误                // const err = new Error(data.description)                // err.data = data                // err.response = response                // throw err                return data            &#125;,            err =&gt; &#123;                if (err &amp;&amp; err.response) &#123;                    switch (err.response.status) &#123;                        case 400:                            err.message = &#x27;请求错误&#x27;                            break                        case 401:                            err.message = &#x27;未授权，请登录&#x27;                            break                        case 403:                            err.message = &#x27;拒绝访问&#x27;                            break                        case 404:                            err.message = `请求地址出错: $&#123;err.response.config.url&#125;`                            break                        case 408:                            err.message = &#x27;请求超时&#x27;                            break                        case 500:                            err.message = &#x27;服务器内部错误&#x27;                            break                        case 501:                            err.message = &#x27;服务未实现&#x27;                            break                        case 502:                            err.message = &#x27;网关错误&#x27;                            break                        case 503:                            err.message = &#x27;服务不可用&#x27;                            break                        case 504:                            err.message = &#x27;网关超时&#x27;                            break                        case 505:                            err.message = &#x27;HTTP版本不受支持&#x27;                            break                        default:                    &#125;                &#125;                console.error(err)                // \b此处我使用的是 element UI 的提示组件                // Message.error(`ERROR: $&#123;err&#125;`);                return Promise.reject(err) // 返回接口返回的错误信息            &#125;        )        //请求处理        instance(options)            .then((res) =&gt; &#123;                resolve(res)                return false            &#125;)            .catch((error) =&gt; &#123;                reject(error)            &#125;)        // 处理结束    &#125;)&#125;\n  api.js接口公共管理文件\n // api接口统一管理import axios from &#x27;./instance&#x27;// 将所有的接口统一起来便于维护// 空气质量接口export const airQuality = (data) =&gt; &#123;    return axios(&#123;        url: &#x27;/util/getAirData&#x27;,        method: &#x27;POST&#x27;,        data,        // handle:true    &#125;)&#125;// 默认全部导出// export default &#123;//     airQuality// &#125;\n使用，可以在main.js中直接导入，使用时，this.$api.airQuality()\n import api from &#x27;./http/api.js&#x27; //引入接口文件Vue.prototype.$api = api; //挂载\n 调用\n this.$api.airQuality(data).then((res)=&gt;&#123;\tconsole.log(JSON.stringify(res));&#125;).catch((err)=&gt;&#123;\tconsole.log(err);&#125;);\n 此方式使用时，项目运行是会一次性加载api文件中的所有接口\n\n方式二，使用时引入\n &lt;template&gt;&lt;/template&gt;&lt;script&gt;import &#123; airQuality &#125; from &quot;@/http/api.js&quot;; //引入使用的接口export default &#123;    data() &#123;        return &#123;                &#125;;    &#125;,    created() &#123;        this.airQuality(); //调用接口    &#125;,    methods: &#123;        airQuality() &#123;            var data = &#123;&#125;;            airQuality(data).then((res) =&gt; &#123;                console.log(JSON.stringify(res));            &#125;);        &#125;    &#125;,&#125;;&lt;/script&gt;\t&lt;style scoped&gt;&lt;/style&gt;\n结束：至此项目成功配置完毕，执行启动命令，打包命令测试环境输出对应，运行成功，其中如有错误还望大家多多指出，谢谢！\n\n\ngithub项目地址github项目地址\nvue-cli2.0与vue3.0+创建出的项目具体有什么不一样，本篇中暂未详细说明\n"},{"title":"vue-cli搭建vue2项目改造ssr","url":"/5e6aae49.html","content":"记录一次vue-cli搭建vue2项目改造ssr全过程，附代码注释。\n通过 vue-cli 创建 vue 项目可参考我之前写的一篇文章 vue-cli4.0搭建vue项目\n安装 vue-server-renderer# 进入项目目录执行npm install vue vue-server-renderer --save\n\n注意\n\n推荐使用 Node.js 版本 6+。\nvue-server-renderer 和 vue 必须匹配版本。\nvue-server-renderer 依赖一些 Node.js 原生模块，因此只能在 Node.js中使用。我们可能会提供一个更简单的构建，可以在将来在其他「JavaScript 运行时(runtime)」运行。\n\n修改 src/router/index.js 文件import Vue from &#x27;vue&#x27;import VueRouter from &#x27;vue-router&#x27;Vue.use(VueRouter)/* 解决访问重复路由报错问题：NavigationDuplicated: Avoided redundant navigation to current location: &quot;/xxx&quot; 开始 */const originalPush = VueRouter.prototype.push// 修改 原型对象中的push方法VueRouter.prototype.push = function push(location) &#123;  return originalPush.call(this, location).catch(err =&gt; err)&#125;/* 解决访问重复路由报错问题：NavigationDuplicated: Avoided redundant navigation to current location: &quot;/xxx&quot; 结束 */const routes = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;Home&#x27;,    component: () =&gt; import(/* webpackChunkName: &quot;home&quot; */ &#x27;../views/Home.vue&#x27;)  &#125;,  &#123;    path: &#x27;/about&#x27;,    name: &#x27;About&#x27;,    // route level code-splitting    // this generates a separate chunk (about.[hash].js) for this route    // which is lazy-loaded when the route is visited.    component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &#x27;../views/About.vue&#x27;)  &#125;]//每次用户请求都需要创建一个新的 router 实例//创建 createRouter 工厂函数export function createRouter() &#123;  return new VueRouter(&#123;    routes  &#125;)&#125;\n\n修改 src/store/index.js 文件import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)const store = new Vuex.Store(&#123;  state: &#123;  &#125;,  mutations: &#123;  &#125;,  actions: &#123;  &#125;,  modules: &#123;  &#125;&#125;)export function createStore() &#123;  return store&#125;\n\n创建 src/app.js 入口文件安装 vuex-router-sync 工具，该工具主要是将 store 跟 router 连接起来。详细了解可参考 Vuex Router Sync\n# 进入项目目录执行npm install vuex-router-sync\n\n代码修改\nimport Vue from &quot;vue&quot;;import App from &#x27;./App.vue&#x27;import &#123; createRouter &#125; from &quot;./router&quot;;import &#123; createStore &#125; from &quot;./store&quot;;// 把 Vue Router 当前的 $route 同步为 Vuex 状态的一部分import &#123; sync &#125; from &quot;vuex-router-sync&quot;// 导出一个工厂函数，用于创建新的// 应用程序、router 和 store 实例export function createApp() &#123;  // 创建router实例  const router = createRouter()  const store = createStore()  // 同步路由状态(route state)到 store  sync(store, router)  // 创建应用程序实例，将 router 和 store 注入  const app = new Vue(&#123;    router,    store,    // 根据实例简单的渲染用用程序组件    render: h =&gt; h(App)  &#125;)  // 暴露 app, router 和 store  return &#123; app, router, store &#125;&#125;\n\n创建 src/entry-server.js 文件服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多事情 - 但是稍后我们将在此执行服务器端路由匹配 (server-side route matching) 和数据预取逻辑 (data pre-fetching logic)。\n代码\n// entry-server.jsimport &#123; createApp &#125; from &quot;./app&quot;export default context =&gt; &#123;  // 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise，    // 以便服务器能够等待所有的内容在渲染前，    // 就已经准备就绪。  return new Promise((resolve, reject) =&gt; &#123;    const &#123; app, router, store &#125; = createApp()    // 设置服务端 router 的位置    router.push(context.url)    // 等到 router 将可能的异步组件和钩子函数解析完    router.onReady(() =&gt; &#123;      const matchedComponents = router.getMatchedComponents()      // 匹配不到路由，执行reject函数，并返回404      if (!matchedComponents.length) &#123;        return reject(&#123; code: 404 &#125;)      &#125;      // 对所有匹配的路由组件调用 `asyncData()`      Promise.all(matchedComponents.map(Component =&gt; &#123;        if (Component.asyncData) &#123;          return Component.asyncData(&#123;            store,            router: router.currentRoute          &#125;)        &#125;      &#125;)).then(() =&gt; &#123;        // 在所有预取钩子(preFetch hook) resolve 后，        // 我们的 store 现在已经填充入渲染应用程序所需的状态。        // 当我们将状态附加到上下文，        // 并且 `template` 选项用于 renderer 时，        // 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。        context.state = store.state         // Promise 应该 resolve 应用程序实例，以便它可以渲染        resolve(app)      &#125;)    &#125;, reject)  &#125;)&#125;\n\n创建 src/entry-client.js 文件客户端 entry 只需创建应用程序，并且将其挂载到 DOM 中：\n代码\n// entry-client.jsimport &#123; createApp &#125; from &#x27;./app&#x27;const &#123; app, router, store &#125; = createApp();if (window.__INITIAL_STATE__) &#123;  store.replaceState(window.__INITIAL_STATE__)&#125;router.onReady(() =&gt; &#123;  // 添加路由钩子函数，用于处理 asyncData.  // 在初始路由 resolve 后执行，  // 以便我们不会二次预取(double-fetch)已有的数据。  // 使用 `router.beforeResolve()`，以便确保所有异步组件都 resolve。  router.beforeResolve((to, from, next) =&gt; &#123;    const matched = router.getMatchedComponents(to)    const prevMatched = router.getMatchedComponents(from)    // 我们只关心非预渲染的组件    // 所以我们对比它们，找出两个匹配列表的差异组件    let diffed = false    const activated = matched.filter((c, i) =&gt; &#123;      return diffed || (diffed = (prevMatched[i] !== c))    &#125;)    if (!activated.length) &#123;      return next()    &#125;    // 这里如果有加载指示器 (loading indicator)，就触发    Promise.all(activated.map(c =&gt; &#123;      if (c.asyncData) &#123;        return c.asyncData(&#123; store, route: to &#125;)      &#125;    &#125;)).then(() =&gt; &#123;      // 停止加载指示器(loading indicator)      next()    &#125;).catch(next)  &#125;)  app.$mount(&#x27;#app&#x27;)&#125;)\n\n创建页面模板 public/index.template.html当你在渲染 Vue 应用程序时，renderer 只从应用程序生成 HTML 标记 (markup)。在这个示例中，我们必须用一个额外的 HTML 页面包裹容器，来包裹生成的 HTML 标记。注意 &lt;!--vue-ssr-outlet--&gt; 注释 – 这里将是应用程序 HTML 标记注入的地方，中间不能有空格。\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;utf-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;  &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt;&lt;/html&gt;\n\n创建一个 Node.js web服务器与服务器集成，在 Node.js 服务器中使用时相当简单直接，例如 Express\n# 进入项目目录执行npm install express --save\n\n项目根目录下创建 server.js 文件，代码如下：\nconst express = require(&#x27;express&#x27;);const fs = require(&#x27;fs&#x27;);const path = require(&#x27;path&#x27;);const &#123; createBundleRenderer &#125; = require(&#x27;vue-server-renderer&#x27;);const app = express();const serverBundle = require(&#x27;./dist/server/vue-ssr-server-bundle.json&#x27;);const clientManifest = require(&#x27;./dist/client/vue-ssr-client-manifest.json&#x27;);const template = fs.readFileSync(path.resolve(&#x27;./public/index.template.html&#x27;), &#x27;utf-8&#x27;);const render = createBundleRenderer(serverBundle, &#123;  runInNewContext: false, // 推荐  template, // （可选）页面模板  clientManifest // （可选）客户端构建 manifest&#125;);app.use(express.static(&#x27;./dist/client&#x27;, &#123; index: false &#125;))app.get(&#x27;*&#x27;, (req, res) =&gt; &#123;  const context = &#123;    title: &#x27;vue2-ssr-template&#x27;,    url: req.url  &#125;  // 这里无需传入一个应用程序，因为在执行 bundle 时已经自动创建过。  // 现在我们的服务器与应用程序已经解耦！  render.renderToString(context, (err, html) =&gt; &#123;    console.log(html)    // 处理异常……    res.end(html)  &#125;)&#125;)// 访问端口const port = 3003;app.listen(port, function () &#123;  console.log(`server started at localhost:$&#123;port&#125;`);&#125;);\n\n配置 vue.config.js\nvue-cli4 脚手架搭建完成后，项目目录中没有 vue.config.js 文件，需要手动创建。vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。\n根目录下创建 vue.config.js ，已创建可忽略。\n\n注意：配置文件中用到了 lodash.merge 合并对象，安装命令 npm install lodash.merge --save\n// vue.config.jsconst VueSSRServerPlugin = require(&#x27;vue-server-renderer/server-plugin&#x27;)const VueSSRClientPlugin = require(&#x27;vue-server-renderer/client-plugin&#x27;)const nodeExternals = require(&#x27;webpack-node-externals&#x27;)const merge = require(&#x27;lodash.merge&#x27;)const TARGET_NODE = process.env.WEBPACK_TARGET === &#x27;node&#x27;const target = TARGET_NODE ? &#x27;server&#x27; : &#x27;client&#x27;module.exports = &#123;  css: &#123;    extract: false  &#125;,  outputDir: &quot;./dist/&quot; + target,  configureWebpack: () =&gt; (&#123;    // 将 entry 指向应用程序的 server / client 文件    entry: `./src/entry-$&#123;target&#125;.js`,    // 对 bundle renderer 提供 source map 支持    devtool: &#x27;source-map&#x27;,    target: TARGET_NODE ? &#x27;node&#x27; : &#x27;web&#x27;,    node: TARGET_NODE ? undefined : false,    output: &#123;      libraryTarget: TARGET_NODE ? &#x27;commonjs2&#x27; : undefined    &#125;,    // https://webpack.js.org/configuration/externals/#function    // https://github.com/liady/webpack-node-externals    // 外置化应用程序依赖模块。可以使服务器构建速度更快，    // 并生成较小的 bundle 文件。    externals: TARGET_NODE      ? nodeExternals(&#123;        // 不要外置化 webpack 需要处理的依赖模块。        // 你可以在这里添加更多的文件类型。例如，未处理 *.vue 原始文件，        // 你还应该将修改 `global`（例如 polyfill）的依赖模块列入白名单        allowlist: [/\\.css$/]      &#125;)      : undefined,    optimization: &#123;      splitChunks: TARGET_NODE ? false : undefined    &#125;,    plugins: [TARGET_NODE ? new VueSSRServerPlugin() : new VueSSRClientPlugin()]  &#125;),  chainWebpack: config =&gt; &#123;    config.module      .rule(&#x27;vue&#x27;)      .use(&#x27;vue-loader&#x27;)      .tap(options =&gt; &#123;        return merge(options, &#123;          optimizeSSR: false        &#125;)      &#125;)  &#125;&#125;\n\n配置项目打包脚本配置脚本需要用到 cross-env 插件，主要是用来运行跨平台设置和使用环境变量的脚本。\n安装\nnpm install cross-env --save\n\n使用\n在 package.json 文件中，scripts选项下，添加以下脚本：\n&quot;scripts&quot;: &#123;  &quot;serve&quot;: &quot;vue-cli-service serve&quot;, // 项目运行命令  &quot;build&quot;: &quot;npm run build:server &amp;&amp; npm run build:client&quot;, // 打包服务端、客户端  &quot;build:client&quot;: &quot;vue-cli-service build&quot;, // 打包客户端  &quot;build:server&quot;: &quot;cross-env WEBPACK_TARGET=node vue-cli-service build&quot;, // 打包服务端  &quot;server&quot;: &quot;node server&quot;, // 启动node服务环境  &quot;start&quot;: &quot;npm run build:server &amp;&amp; npm run build:client &amp;&amp; npm run server&quot; // // 打包服务端、客户端并启动node服务环境&#125;\n\n至此整个ssr改造完成，可通过 npm run start 在本地环境编译打包启动node服务，访问 http://localhost:3003 查看运行效果。\n注意：端口号可根据自己配置进行访问\n查看网页源代码发现根元素上添加了一个特殊的属性：data-server-rendered，该属性让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载\n&lt;div id=&quot;app&quot; data-server-rendered=&quot;true&quot;&gt;......&lt;/div&gt;\n\n最后项目目录结构public├── favicon.ico├── index.html└── index.template.html # 页面模板src├── components # 组件├── router # 路由文件│   └──  index.js├── store # 状态管理│   └──  index.js├── app.js # 通用 entry(universal entry)├── App.vue├── entry-client.js # 仅运行于浏览器└── entry-server.js # 仅运行于服务器vue.config.js # vue构建配置\n\n打包后 dist 目录结构client # 客户端打包文件├── img├── js├── favicon.ico├── index.html├── index.template.html└── vue-ssr-client-manifest.jsonserver # 服务端打包文件└── vue-ssr-server-bundle.json\n\n参考资料Vue CLIVue.jsVue RouterVuexVue SSR 指南\n"},{"title":"vue spa应用seo优化方案（预渲染）","url":"/fcfe716b.html","content":"预渲染能与服务端渲染一样提高 SEO 优化，但前者比后者需要更少的配置，实现成本低。弱网环境下，预渲染能更快地呈现页面内容，减少页面可见时间。本篇文章主要介绍了本人实现预渲染的一个过程。\n\n从 meta 标签中读取 keywords 、 description 的内容。\n\n根据语义化的 html 的标签爬取和分析内容。一个整体都是用 div 标签的网站和正确使用了 html5 标签的效果是不一样的。\n\n读取 a 标签里的链接，通过 a 标签的链接可以跳转到别的网站。（爬虫是先跳转，还是继续爬内容再跳转，就看算法是广度优先还是深度优先了）\n\n像 h1 - h6 标签是具有不同程度的强调意义的。 一般将 h1 视为重要内容。同样有强调内容还有 strong 、 em 标签。\n技术栈vue v2.0 + vue-router  + webpack + prerender-spa-plugin + vue-meta-info + vue-cli v2 \n具体步骤-使用 npm 或 yarn 安装 prerender-spa-plugin 和 vue-meta-info 的过程就不描述了。 \n-在webpack中配置 prerender-spa-plugin \n-配置先弄懂要配置在哪个文件里，配置是否生效。 vue-cli2 的配置文件很多，对这些文件不了解的话，很容易配置错地方。 \n-这个配置只需要在 build 的时候可以生成预渲染好的html，所以应该配置在 build/webpack.prod.conf.js 这个文件里。 \n//在build/webpack.prod.conf.js添加引入const PrerenderSpaPlugin = require(&#x27;prerender-spa-plugin&#x27;)//解决seoconst Renderer = PrerenderSpaPlugin.PuppeteerRenderer//解决seoconst webpackConfig = merge(baseWebpackConfig, &#123;    plugins: [        // vue-cli生成的配置中就已有这个了，不要动        new HtmlWebpackPlugin(&#123;            filename: config.build.index,            template: &#x27;index.html&#x27;,            inject: true,            minify: &#123;                removeComments: true,                collapseWhitespace: true,                removeAttributeQuotes: true            &#125;,            chunksSortMode: &#x27;dependency&#x27;        &#125;),                // 在vue-cli生成的文件的基础上，只有下面这个才是我们要配置的        new PrerenderSPAPlugin(&#123;            // 生成文件的路径，也可以与webpakc打包的一致。            // 下面这句话非常重要！！！            // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。            staticDir: path.join(__dirname, &#x27;../dist&#x27;),                        // 对应自己的路由文件，比如index有参数，就需要写成 /index/param1。            routes: [&#x27;/&#x27;, &#x27;/index&#x27;, &#x27;/about&#x27;, &#x27;/alPay&#x27;, &#x27;/wxPay&#x27;],                        // 这个很重要，如果没有配置这段，也不会进行预编译            renderer: new Renderer(&#123;                inject: &#123;                  foo: &#x27;bar&#x27;                &#125;,                headless: false,                // 在 main.js 中 document.dispatchEvent(new Event(&#x27;render-event&#x27;))，两者的事件名称要对应上。                renderAfterDocumentEvent: &#x27;render-event&#x27;            &#125;)        &#125;)    ]&#125;)//然后在main.js中添加引入import MetaInfo from &#x27;vue-meta-info&#x27;Vue.use(MetaInfo)new Vue(&#123;    el: &#x27;#app&#x27;,    router,    store,    render: h =&gt; h(App),        /* 这句非常重要，否则预渲染将不会启动 */    mounted () &#123;        document.dispatchEvent(new Event(&#x27;render-event&#x27;))    &#125;&#125;)\n\n然后运行一下 npm run build 。看一下生成的 dist 的目录里是不是有每个路由名称对应的文件夹。然后找个 目录里 的 index.html 用IDE打开，看文件内容里是否有该文件应该有的内容。有的话，这步就成功了 \n在vue中使用 vue-meta-info&lt;template&gt;\t&lt;div&gt;\t\t首页\t&lt;/div&gt;&lt;/template&gt;export default &#123;    metaInfo: &#123;        title: &#x27;我是一个title&#x27;,        meta: [            &#123;                name: &#x27;keywords&#x27;,                content: &#x27;关键字1,关键字2,关键字3&#x27;            &#125;,            &#123;                name: &#x27;description&#x27;,                content: &#x27;这是一段网页的描述&#x27;            &#125;        ]    &#125;&#125;\n\n下面是特别需要注意的事项（否则将会出现问题）\n这里使用的 prerender-spa-plugin 的版本是 3.2.1 ，在 2.x 的版本中有个写法如下 \nvar PrerenderSpaPlugin = require(&#x27;prerender-spa-plugin&#x27;) const webpackConfig = merge(baseWebpackConfig, &#123;    plugins: &#123;        //配置 prerender-spa-plugin        new PrerenderSpaPlugin(            // 生成文件的路径，此处与webpack打包地址一致            path.join(config.build.assetsRoot), //config.build.assetsRoot为vue cli生成的配置，打包后的文件地址            // 配置要做预渲染的路由，只支持h5 history方式            [ &#x27;/&#x27;, &#x27;/test&#x27;]        )    &#125;&#125;)\n\n以上 2.x 的写法，在 3.x 的版本会提示一个警告，让你采用对象的形式 \n\nroute 的 history 模式就是如下代码中配置 \n预渲染方式下的 route 采用 history 模式，经过试验 得采用history模式，否则每个index.html文件的内容都会是一样的。 \nexport default new Router(&#123;    mode: &#x27;history&#x27;,    routes: [        // ...    ]&#125;)\n\n注意事项1:history 模式下的route，将不会以 hash 的形式展示，也就是说，URL里没有 # 了。\n注意事项2:但是需要注意history这种模式会出现页面刷新后出现404页面问题。vue.js官方教程里提到的解决办法可以参考\n\n\n\n\n"},{"title":"记常遇到的JS手写","url":"/51a3f45e.html","content":"面试中遇到的一些JS手写题以及一些常见的JS手写题记录。\n手写 call、apply 和 bindcall、apply和bind三者的用法和区别call、apply和bind这三个函数的第一个参数都是this指向函数，第二个参数有差别\n\ncall后面的参数都是直接以逗号分隔开依次写在后面传递的；\napply的后一个参数是以数组形式传递的，有多个参数都需要写在数组中进行传递；\nbind的除了返回是函数之外，他的参数和call一样；\n\n三者参数不限定是string类型，允许是各种类型，包括函数、object等。\n手写 call// 原型myCall方法Function.prototype.myCall = function (context) &#123;    console.log(this); // getName函数    console.log(context); // 传递的参数person1    if (typeof this !== &#x27;function&#x27;) &#123;        throw new Error(&#x27;error&#x27;);    &#125;    context = context || window;    // 考虑参数    // 拿到除了第一个参数之外的参数    var args = [...arguments].slice(1);    context.fn = this; // 改变this指向    var result = context.fn(...args);    return result;&#125;// 测试var person = &#123;\tname: &#x27;执笔写下信念&#x27;,    getName: function () &#123;        return this.name    &#125;&#125;;var person1 = &#123;    name: &#x27;小手冰凉&#x27;&#125;;console.log(person.getName.myCall(person1, 1, 2, 3));\n\n手写 applyFunction.prototype.myApply = function (context) &#123;    console.log(context); // 参数    console.log(this); // getName函数    context = context || window;    context.fn = this;    let result;    if (arguments[1]) &#123;        result = context.fn([...arguments[1]]);    &#125; else &#123;        result = context.fn();    &#125;    delete context.fn;    return result;&#125;// 测试const person = &#123;\tname = &quot;小手冰凉&quot;,    getName: function () &#123;        console.log(arguments)        console.log(this.name);    &#125;&#125;;const people = &#123;    name: &quot;纸币写下信念&quot;&#125;;console.log(person.getName.myApply(people, [1, 2, 3]));\n手写 bindFunction.prototype.myBind = function (context) &#123;  const self = this;  if (typeof this !== &#x27;function&#x27;) &#123;    throw new Error(&#x27;error&#x27;);  &#125;  context = context || window;  // 获取除第一个参数外的所有参数  const args = [...arguments].slice(1);  context.fn = self;  return function () &#123;    // 参数合并    const allArg = [...args, ...arguments];    const result = context.fn(...allArg);    return result;  &#125;&#125;// 测试var person = &#123;  name: &#x27;纸币写下信念&#x27;,  getName: function () &#123;    return this.name  &#125;&#125;;var person1 = &#123;  name: &#x27;小手冰凉&#x27;&#125;;const p1 = person.getName.myBind(person1, 10, 20, 30);console.log(p1(40, 50));\n\n手写 flat// 实现一个flatArray.prototype.myFlat = function (n) &#123;  // 不传n默认为1  if (!n) &#123;    n = 1  &#125;  const self = this;  const fn = (arr, n) =&gt; &#123;    let res = [];    if (n === 0) &#123;      return arr;    &#125;    for (let i = 0; i &lt; arr.length; i++) &#123;      if (Array.isArray(arr[i])) &#123;        res = res.concat(fn(arr[i], n - 1));      &#125; else &#123;        res = res.concat(arr[i]);      &#125;    &#125;    return res;  &#125;  return fn(self, n);&#125;// reduce方式function myFlat(arr, n) &#123;  if (n === 0) &#123;    return arr;  &#125;  return arr.reduce((res, value) =&gt; &#123;    if (Array.isArray(value)) &#123;      res = res.concat(myFlat(value, n - 1));    &#125; else &#123;      res = res.concat(value);    &#125;    return res;  &#125;, [])&#125;const arr = [1, 2, [1, 3, [54, 3, 4]], [22, 546, [123, 435, 123], 3]];console.log(arr.myFlat(2));\n\n函数柯里化柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。\nfunction curry(fn, ...args) &#123;  const &#123; length &#125; = fn;  if (length &lt;= args.length) &#123;    return fn(...args);  &#125; else &#123;    return curry.bind(null, fn, ...args)  &#125;&#125;// 普通函数function fn(a, b, c) &#123;  console.log(a, b, c);&#125;// 柯里化函数const _fn = curry(fn);// 测试fn(1, 2, 3); // 1 2 3_fn(1)(2)(3); // 1 2 3 \n\n手写 Promise// 基础架构function MyPromise(excutor) &#123;  let self = this;  self.status = &#x27;pending&#x27;;  self.value = null;  self.reason = null;  // 发布订阅模式、支持异步  self.onFulfilledCallback = [];  self.onRejectedCallback = [];  // 成功回调  function resolve(value) &#123;    // 状态判断    if (self.status === &#x27;pending&#x27;) &#123;      self.value = value;      self.status = &#x27;fulfilled&#x27;;      // 状态改变就  执行 =&gt; 发布      self.onFulfilledCallback.forEach(item =&gt; item(value));    &#125;  &#125;  // 失败回调  function reject(reason) &#123;    if (self.status === &#x27;pending&#x27;) &#123;      self.reason = reason;      self.status = &#x27;rejected&#x27;;      // 状态改变就  执行 =&gt; 发布      self.onFulfilledCallback.forEach(item =&gt; item(reason));    &#125;  &#125;  // 添加立即执行器  try &#123;    excutor(resolve, reject);  &#125; catch (error) &#123;    reject(error);  &#125;&#125;// 2. then方法，接收一个成功的回调和一个失败的回调MyPromise.prototype.then = function (onFulfilled, onRejected) &#123;  // 6. 状态更改了就会调用.then()  onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : function (data) &#123; return data &#125;;  onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : function (err) &#123; throw err &#125;;  let self = this;  // 8. 订阅操作  // if (self.status === &#x27;pending&#x27;) &#123;  //     self.onFulfilledCallback.push(onFulfilled);  //     self.onRejectedCallback.push(onRejected);  // &#125;  if (self.status === &#x27;pending&#x27;) &#123;    return new MyPromise((resolve, reject) =&gt; &#123;      self.onFulfilledCallback.push(() =&gt; &#123;        let x = onFulfilled(self.value);        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x);      &#125;);      self.onRejectedCallback.push(() =&gt; &#123;        let x = onFulfilled(self.value);        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x);      &#125;);    &#125;);  &#125;  if (self.status === &#x27;fulfilled&#x27;) &#123;    return new MyPromise((resolve, reject) =&gt; &#123;      try &#123;        let x = onFulfilled(self.value);        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x);      &#125; catch (error) &#123;        reject(error);      &#125;    &#125;);  &#125;  if (self.status === &#x27;rejected&#x27;) &#123;    return new MyPromise((resolve, reject) =&gt; &#123;      try &#123;        let x = onRejected(self.value);        x instanceof MyPromise ? x.then(resolve, reject) : resolve(x);      &#125; catch (error) &#123;        reject(error);      &#125;    &#125;);  &#125;&#125;MyPromise.prototype.catch = function (fn) &#123;  return this.then(null, fn);&#125;// MyPromise.resolve()方法MyPromise.resolve = function (value) &#123;  return value instanceof MyPromise ? value : new MyPromise(resolve =&gt; resolve(value));&#125;// MyPromise.reject()方法MyPromise.reject = function (error) &#123;  return new MyPromise(reject =&gt; reject(error));&#125;// MyPromise.all()方法MyPromise.all = function(promiseArr) &#123;  let count = 0;  let result = [];  return new MyPromise((resolve, reject) =&gt; &#123;    // promiseArr为0直接返回result    if(!promiseArr.length)&#123;      resolve(result);    &#125;    promiseArr.forEach((p, idx) =&gt; &#123;      MyPromise.resolve(p).then(value =&gt; &#123;        count++;        result[idx] = value;        if(count === promiseArr.length)&#123;          resolve(result);        &#125;      &#125;).catch(error =&gt; &#123;        reject(error);      &#125;)    &#125;)  &#125;)&#125;// MyPromise.race()方法MyPromise.race = function(promiseArr) &#123;   return new MyPromise((resolve, reject) =&gt; &#123;     promiseArr.forEach(p =&gt; &#123;       MyPromise.resolve(p).then(value =&gt; &#123;         resolve(value);       &#125;).catch(error =&gt; &#123;         reject(error);       &#125;)     &#125;)   &#125;)&#125;// 测试let demo = new MyPromise((resolve, reject) =&gt; &#123;  console.log(&#x27;MyPromise 已经完成&#x27;);  setTimeout(() =&gt; &#123;    resolve(1);  &#125;, 1000)&#125;);demo.then((data) =&gt; &#123;  console.log(data);&#125;);"}]